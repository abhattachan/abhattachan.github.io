{"version":3,"sources":["../../../node_modules/opentelemetry-instrumentation-fetch-node/src/index.ts"],"sourcesContent":["/*\n * Portions from https://github.com/elastic/apm-agent-nodejs\n * Copyright Elasticsearch B.V. and other contributors where applicable.\n * Licensed under the BSD 2-Clause License; you may not use this file except in\n * compliance with the BSD 2-Clause License.\n *\n */\nimport diagch from 'node:diagnostics_channel';\n\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions';\nimport { Instrumentation, InstrumentationConfig } from '@opentelemetry/instrumentation';\nimport {\n  Attributes,\n  context,\n  Meter,\n  MeterProvider,\n  metrics,\n  propagation,\n  Span,\n  SpanKind,\n  SpanStatusCode,\n  trace,\n  Tracer,\n  TracerProvider,\n} from '@opentelemetry/api';\n\ninterface ListenerRecord {\n  name: string;\n  channel: diagch.Channel;\n  onMessage: diagch.ChannelListener;\n}\n\ninterface FetchRequest {\n  method: string;\n  origin: string;\n  path: string;\n  headers: string | string[];\n}\n\ninterface FetchResponse {\n  headers: Buffer[];\n  statusCode: number;\n}\n\nexport interface FetchInstrumentationConfig extends InstrumentationConfig {\n  ignoreRequestHook?: (request: FetchRequest) => boolean;\n  onRequest?: (args: {\n    request: FetchRequest;\n    span: Span;\n    additionalHeaders: Record<string, string | string[]>;\n  }) => void;\n}\n\nfunction getMessage(error: Error) {\n  if (error instanceof AggregateError) {\n    return error.errors.map((e) => e.message).join(', ');\n  }\n  return error.message;\n}\n\n// Get the content-length from undici response headers.\n// `headers` is an Array of buffers: [k, v, k, v, ...].\n// If the header is not present, or has an invalid value, this returns null.\nfunction contentLengthFromResponseHeaders(headers: Buffer[]) {\n  const name = 'content-length';\n  for (let i = 0; i < headers.length; i += 2) {\n    const k = headers[i];\n    if (k.length === name.length && k.toString().toLowerCase() === name) {\n      const v = Number(headers[i + 1]);\n      if (!Number.isNaN(Number(v))) {\n        return v;\n      }\n      return undefined;\n    }\n  }\n  return undefined;\n}\n\nasync function loadFetch() {\n  try {\n    await fetch('');\n  } catch (_) {\n    //\n  }\n}\n\n// A combination of https://github.com/elastic/apm-agent-nodejs and\n// https://github.com/gadget-inc/opentelemetry-instrumentations/blob/main/packages/opentelemetry-instrumentation-undici/src/index.ts\nexport class FetchInstrumentation implements Instrumentation {\n  // Keep ref to avoid https://github.com/nodejs/node/issues/42170 bug and for\n  // unsubscribing.\n  private channelSubs: Array<ListenerRecord> | undefined;\n\n  private spanFromReq = new WeakMap<FetchRequest, Span>();\n\n  private tracer: Tracer;\n\n  private config: FetchInstrumentationConfig;\n\n  private meter: Meter;\n\n  public readonly instrumentationName = 'opentelemetry-instrumentation-node-18-fetch';\n\n  public readonly instrumentationVersion = '1.0.0';\n\n  public readonly instrumentationDescription =\n    'Instrumentation for Node 18 fetch via diagnostics_channel';\n\n  private subscribeToChannel(diagnosticChannel: string, onMessage: diagch.ChannelListener) {\n    const channel = diagch.channel(diagnosticChannel);\n    channel.subscribe(onMessage);\n    this.channelSubs!.push({\n      name: diagnosticChannel,\n      channel,\n      onMessage,\n    });\n  }\n\n  constructor(config: FetchInstrumentationConfig) {\n    // Force load fetch API (since it's lazy loaded in Node 18)\n    loadFetch();\n    this.channelSubs = [];\n    this.meter = metrics.getMeter(this.instrumentationName, this.instrumentationVersion);\n    this.tracer = trace.getTracer(this.instrumentationName, this.instrumentationVersion);\n    this.config = { ...config };\n  }\n\n  disable(): void {\n    this.channelSubs?.forEach((sub) => sub.channel.unsubscribe(sub.onMessage));\n  }\n\n  enable(): void {\n    this.subscribeToChannel('undici:request:create', (args) =>\n      this.onRequest(args as { request: FetchRequest }),\n    );\n    this.subscribeToChannel('undici:request:headers', (args) =>\n      this.onHeaders(args as { request: FetchRequest; response: FetchResponse }),\n    );\n    this.subscribeToChannel('undici:request:trailers', (args) =>\n      this.onDone(args as { request: FetchRequest }),\n    );\n    this.subscribeToChannel('undici:request:error', (args) =>\n      this.onError(args as { request: FetchRequest; error: Error }),\n    );\n  }\n\n  setTracerProvider(tracerProvider: TracerProvider): void {\n    this.tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);\n  }\n\n  public setMeterProvider(meterProvider: MeterProvider): void {\n    this.meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);\n  }\n\n  setConfig(config: InstrumentationConfig): void {\n    this.config = { ...config };\n  }\n\n  getConfig(): InstrumentationConfig {\n    return this.config;\n  }\n\n  onRequest({ request }: { request: FetchRequest }): void {\n    // Don't instrument CONNECT - see comments at:\n    // https://github.com/elastic/apm-agent-nodejs/blob/c55b1d8c32b2574362fc24d81b8e173ce2f75257/lib/instrumentation/modules/undici.js#L24\n    if (request.method === 'CONNECT') {\n      return;\n    }\n    if (this.config.ignoreRequestHook && this.config.ignoreRequestHook(request) === true) {\n      return;\n    }\n\n    const span = this.tracer.startSpan(`HTTP ${request.method}`, {\n      kind: SpanKind.CLIENT,\n      attributes: {\n        [SemanticAttributes.HTTP_URL]: getAbsoluteUrl(request.origin, request.path),\n        [SemanticAttributes.HTTP_METHOD]: request.method,\n        [SemanticAttributes.HTTP_TARGET]: request.path,\n        'http.client': 'fetch',\n      },\n    });\n    const requestContext = trace.setSpan(context.active(), span);\n    const addedHeaders: Record<string, string> = {};\n    propagation.inject(requestContext, addedHeaders);\n\n    if (this.config.onRequest) {\n      this.config.onRequest({ request, span, additionalHeaders: addedHeaders });\n    }\n\n    if (Array.isArray(request.headers)) {\n      request.headers.push(...Object.entries(addedHeaders).flat());\n    } else {\n      request.headers += Object.entries(addedHeaders)\n        .map(([k, v]) => `${k}: ${v}\\r\\n`)\n        .join('');\n    }\n    this.spanFromReq.set(request, span);\n  }\n\n  onHeaders({ request, response }: { request: FetchRequest; response: FetchResponse }): void {\n    const span = this.spanFromReq.get(request);\n\n    if (span !== undefined) {\n      // We are currently *not* capturing response headers, even though the\n      // intake API does allow it, because none of the other `setHttpContext`\n      // uses currently do.\n\n      const cLen = contentLengthFromResponseHeaders(response.headers);\n      const attrs: Attributes = {\n        [SemanticAttributes.HTTP_STATUS_CODE]: response.statusCode,\n      };\n      if (cLen) {\n        attrs[SemanticAttributes.HTTP_RESPONSE_CONTENT_LENGTH] = cLen;\n      }\n      span.setAttributes(attrs);\n      span.setStatus({\n        code: response.statusCode >= 400 ? SpanStatusCode.ERROR : SpanStatusCode.OK,\n        message: String(response.statusCode),\n      });\n    }\n  }\n\n  onDone({ request }: { request: FetchRequest }): void {\n    const span = this.spanFromReq.get(request);\n    if (span !== undefined) {\n      span.end();\n      this.spanFromReq.delete(request);\n    }\n  }\n\n  onError({ request, error }: { request: FetchRequest; error: Error }): void {\n    const span = this.spanFromReq.get(request);\n    if (span !== undefined) {\n      span.recordException(error);\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: getMessage(error),\n      });\n      span.end();\n    }\n  }\n}\n\nfunction getAbsoluteUrl(origin: string, path: string = '/'): string {\n  const url = `${origin}`;\n\n  if (origin.endsWith('/') && path.startsWith('/')) {\n    return `${url}${path.slice(1)}`;\n  }\n\n  if (!origin.endsWith('/') && !path.startsWith('/')) {\n    return `${url}/${path.slice(1)}`;\n  }\n\n  return `${url}${path}`;\n}\n"],"mappings":";;uSAOA,IAAAA,EAAAC,EAAA,EAAA,0BAAA,CAAA,EAEAC,EAAA,WAEAC,EAAA,WA0CA,SAASC,EAAWC,EAAY,CAC9B,OAAIA,aAAiB,eACZA,EAAM,OAAO,IAAKC,GAAMA,EAAE,OAAO,EAAE,KAAK,IAAI,EAE9CD,EAAM,OACf,CAKA,SAASE,EAAiCC,EAAiB,CACzD,IAAMC,EAAO,iBACb,QAASC,EAAI,EAAGA,EAAIF,EAAQ,OAAQE,GAAK,EAAG,CAC1C,IAAMC,EAAIH,EAAQE,CAAC,EACnB,GAAIC,EAAE,SAAWF,EAAK,QAAUE,EAAE,SAAQ,EAAG,YAAW,IAAOF,EAAM,CACnE,IAAMG,EAAI,OAAOJ,EAAQE,EAAI,CAAC,CAAC,EAC/B,OAAK,OAAO,MAAM,OAAOE,CAAC,CAAC,EAG3B,OAFSA,CAGX,CACF,CAEF,CAEA,eAAeC,GAAS,CACtB,GAAI,CACF,MAAM,MAAM,EAAE,CAChB,MAAY,CAEZ,CACF,CAIA,IAAaC,EAAb,KAAiC,CAGvB,YAEA,YAAc,IAAI,QAElB,OAEA,OAEA,MAEQ,oBAAsB,8CAEtB,uBAAyB,QAEzB,2BACd,4DAEM,mBAAmBC,EAA2BC,EAAiC,CACrF,IAAMC,EAAUjB,EAAA,QAAO,QAAQe,CAAiB,EAChDE,EAAQ,UAAUD,CAAS,EAC3B,KAAK,YAAa,KAAK,CACrB,KAAMD,EACN,QAAAE,EACA,UAAAD,EACD,CACH,CAEA,YAAYE,EAAkC,CAE5CL,EAAS,EACT,KAAK,YAAc,CAAA,EACnB,KAAK,MAAQV,EAAA,QAAQ,SAAS,KAAK,oBAAqB,KAAK,sBAAsB,EACnF,KAAK,OAASA,EAAA,MAAM,UAAU,KAAK,oBAAqB,KAAK,sBAAsB,EACnF,KAAK,OAAS,CAAE,GAAGe,CAAM,CAC3B,CAEA,SAAO,CACL,KAAK,aAAa,QAASC,GAAQA,EAAI,QAAQ,YAAYA,EAAI,SAAS,CAAC,CAC3E,CAEA,QAAM,CACJ,KAAK,mBAAmB,wBAA0BC,GAChD,KAAK,UAAUA,CAAiC,CAAC,EAEnD,KAAK,mBAAmB,yBAA2BA,GACjD,KAAK,UAAUA,CAA0D,CAAC,EAE5E,KAAK,mBAAmB,0BAA4BA,GAClD,KAAK,OAAOA,CAAiC,CAAC,EAEhD,KAAK,mBAAmB,uBAAyBA,GAC/C,KAAK,QAAQA,CAA+C,CAAC,CAEjE,CAEA,kBAAkBC,EAA8B,CAC9C,KAAK,OAASA,EAAe,UAAU,KAAK,oBAAqB,KAAK,sBAAsB,CAC9F,CAEO,iBAAiBC,EAA4B,CAClD,KAAK,MAAQA,EAAc,SAAS,KAAK,oBAAqB,KAAK,sBAAsB,CAC3F,CAEA,UAAUJ,EAA6B,CACrC,KAAK,OAAS,CAAE,GAAGA,CAAM,CAC3B,CAEA,WAAS,CACP,OAAO,KAAK,MACd,CAEA,UAAU,CAAE,QAAAK,CAAO,EAA6B,CAM9C,GAHIA,EAAQ,SAAW,WAGnB,KAAK,OAAO,mBAAqB,KAAK,OAAO,kBAAkBA,CAAO,IAAM,GAC9E,OAGF,IAAMC,EAAO,KAAK,OAAO,UAAU,QAAQD,EAAQ,MAAM,GAAI,CAC3D,KAAMpB,EAAA,SAAS,OACf,WAAY,CACV,CAACD,EAAA,mBAAmB,QAAQ,EAAGuB,EAAeF,EAAQ,OAAQA,EAAQ,IAAI,EAC1E,CAACrB,EAAA,mBAAmB,WAAW,EAAGqB,EAAQ,OAC1C,CAACrB,EAAA,mBAAmB,WAAW,EAAGqB,EAAQ,KAC1C,cAAe,SAElB,EACKG,EAAiBvB,EAAA,MAAM,QAAQA,EAAA,QAAQ,OAAM,EAAIqB,CAAI,EACrDG,EAAuC,CAAA,EAC7CxB,EAAA,YAAY,OAAOuB,EAAgBC,CAAY,EAE3C,KAAK,OAAO,WACd,KAAK,OAAO,UAAU,CAAE,QAAAJ,EAAS,KAAAC,EAAM,kBAAmBG,CAAY,CAAE,EAGtE,MAAM,QAAQJ,EAAQ,OAAO,EAC/BA,EAAQ,QAAQ,KAAK,GAAG,OAAO,QAAQI,CAAY,EAAE,KAAI,CAAE,EAE3DJ,EAAQ,SAAW,OAAO,QAAQI,CAAY,EAC3C,IAAI,CAAC,CAAChB,EAAGC,CAAC,IAAM,GAAGD,CAAC,KAAKC,CAAC;CAAM,EAChC,KAAK,EAAE,EAEZ,KAAK,YAAY,IAAIW,EAASC,CAAI,CACpC,CAEA,UAAU,CAAE,QAAAD,EAAS,SAAAK,CAAQ,EAAsD,CACjF,IAAMJ,EAAO,KAAK,YAAY,IAAID,CAAO,EAEzC,GAAIC,IAAS,OAAW,CAKtB,IAAMK,EAAOtB,EAAiCqB,EAAS,OAAO,EACxDE,EAAoB,CACxB,CAAC5B,EAAA,mBAAmB,gBAAgB,EAAG0B,EAAS,YAE9CC,IACFC,EAAM5B,EAAA,mBAAmB,4BAA4B,EAAI2B,GAE3DL,EAAK,cAAcM,CAAK,EACxBN,EAAK,UAAU,CACb,KAAMI,EAAS,YAAc,IAAMzB,EAAA,eAAe,MAAQA,EAAA,eAAe,GACzE,QAAS,OAAOyB,EAAS,UAAU,EACpC,CACH,CACF,CAEA,OAAO,CAAE,QAAAL,CAAO,EAA6B,CAC3C,IAAMC,EAAO,KAAK,YAAY,IAAID,CAAO,EACrCC,IAAS,SACXA,EAAK,IAAG,EACR,KAAK,YAAY,OAAOD,CAAO,EAEnC,CAEA,QAAQ,CAAE,QAAAA,EAAS,MAAAlB,CAAK,EAA2C,CACjE,IAAMmB,EAAO,KAAK,YAAY,IAAID,CAAO,EACrCC,IAAS,SACXA,EAAK,gBAAgBnB,CAAK,EAC1BmB,EAAK,UAAU,CACb,KAAMrB,EAAA,eAAe,MACrB,QAASC,EAAWC,CAAK,EAC1B,EACDmB,EAAK,IAAG,EAEZ,GAxJFO,EAAA,qBAAAjB,EA2JA,SAASW,EAAeO,EAAgBC,EAAe,IAAG,CACxD,IAAMC,EAAM,GAAGF,CAAM,GAErB,OAAIA,EAAO,SAAS,GAAG,GAAKC,EAAK,WAAW,GAAG,EACtC,GAAGC,CAAG,GAAGD,EAAK,MAAM,CAAC,CAAC,GAG3B,CAACD,EAAO,SAAS,GAAG,GAAK,CAACC,EAAK,WAAW,GAAG,EACxC,GAAGC,CAAG,IAAID,EAAK,MAAM,CAAC,CAAC,GAGzB,GAAGC,CAAG,GAAGD,CAAI,EACtB","names":["node_diagnostics_channel_1","__importDefault","semantic_conventions_1","api_1","getMessage","error","e","contentLengthFromResponseHeaders","headers","name","i","k","v","loadFetch","FetchInstrumentation","diagnosticChannel","onMessage","channel","config","sub","args","tracerProvider","meterProvider","request","span","getAbsoluteUrl","requestContext","addedHeaders","response","cLen","attrs","exports","origin","path","url"]}